bool
handle(ClientWindow *cw, std::string line)
{
  stringstream ss(line);
  string cmd;

  ss >> cmd;

  // Remove leading whitespace
  cmd = cmd.erase(0, cmd.find_first_not_of(" \t\n\r\f\v"));

  // If its zero length ignore it
  if (cmd.size() == 0) return false;

  // If its quit, then quit
  else if (cmd == "quit") return true;

  // If its break, then break
  else if (cmd == "break") brk();

  // If its 'file', open file and process its contents
  else if (cmd == "file")
  {
    string filename;
    ss >> filename;

    ifstream ifs(filename);
    if (ifs)
      handle_commands(cw, (istream*)&ifs);
    else
      std::cerr << "unable to open " << filename << "\n";
  }
 
  // Otherwise, send the line to the server
  else
  {
    if (! cw->CSendRecv(line))
    {
      cerr << "send/receive failed\n";
      exit(1);
    }

    if (cmd != "ok")
      cout << "reply: " << line << "\n";
  }

  return false;
}


void
handle_commands(ClientWindow *cw, istream *is)
{
  string cmd = "", tmp; bool done = false;
  cerr << "? ";
  while (!done && std::getline(*is, tmp))
  {
    for (size_t n = tmp.find(";"); ! done && n != string::npos; n = tmp.find(";"))
    {
      string prefix = tmp.substr(0, n);
      if (cmd == "") cmd = prefix; else cmd = cmd + " " + prefix;
      done = handle(cw, cmd);
      cmd = "";
      tmp = tmp.substr(n+1);
    }
    if (! done)
    {
      if (cmd == "") cmd = tmp; else cmd = cmd + " " + tmp;
    }
    cerr << "? ";
  }
  if (cmd != "")
    handle(cw, cmd);
}

