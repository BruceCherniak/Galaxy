CMakeLists.txt:## Licensed under the Apache License, Version 2.0 (the "License");            ##
CMakeLists.txt:## distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  ##
CMakeLists.txt:set(BINS "")
CMakeLists.txt:set(SERVERS "")
CMakeLists.txt:set(LIBS "")
ClientWindow.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
ClientWindow.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
ClientWindow.cpp:#include "ClientWindow.h"
ClientWindow.cpp:#include "ImageWriter.h"
ClientWindow.cpp:  std::string so("libgxy_module_viewer.so");
ClientWindow.cpp:    std::cerr << "Server-side library load failed\n";
ClientWindow.cpp:  wndw << "window " << width << " " << height;
ClientWindow.cpp:  // std::cerr << "n = " << n << " f = " << frame << "\n";
ClientWindow.cpp:  // std::cerr << "  p[0]: " << p[0].x << " " << p[0].y << "\n";
ClientWindow.cpp:  // std::cerr << "  p[n-1]: " << p[n-1].x << " " << p[n-1].y << "\n";
ClientWindow.cpp:        std::cerr << "pixel error: " << p->x << " " << p->y << "\n";
ClientWindow.cpp:					std::cerr << "A last " << pix[0] << " " << pix[1] << " " << pix[2] << "\n"
ClientWindow.cpp:										<< "  cont " << p->r << " " << p->g << " " << p->b << "\n"
ClientWindow.cpp:										<< "  next " << r << " " << g << " " << b << "\n";
ClientWindow.cpp:							std::cerr << "B " << p->r << " " << p->g << " " << p->b << "\n";
ClientWindow.cpp:							std::cerr << "C last is overridden by " << p->r << " " << p->g << " " << p->b << "\n";
ClientWindow.cpp:          s << "partial-" << current_partial_frame_count << ".png";
ClientWindow.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
ClientWindow.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
ClientWindow.h:#include "Pixel.h"
ClientWindow.h:#include "SocketHandler.h"
ClientWindow.h:      if (getenv("GXY_N_PARTIAL_FRAMES"))
ClientWindow.h:        number_of_partial_frames = atoi(getenv("GXY_N_PARTIAL_FRAMES"));
CommandLine.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
CommandLine.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
CommandLine.cpp:#include "CommandLine.h"
CommandLine.cpp:static void brk() { std::cerr << "break\n"; }
CommandLine.cpp:  cmd = cmd.erase(0, cmd.find_first_not_of(" \t\n\r\f\v"));
CommandLine.cpp:  else if (cmd == "quit") return true;
CommandLine.cpp:  else if (cmd == "break") brk();
CommandLine.cpp:  else if (cmd == "file")
CommandLine.cpp:      std::cerr << "unable to open " << filename << "\n";
CommandLine.cpp:      std::cerr << "send/receive failed\n";
CommandLine.cpp:    if (cmd != "ok")
CommandLine.cpp:      std::cout << "reply: " << line << "\n";
CommandLine.cpp:    std::cerr << "unrecognized command: " << line;
CommandLine.cpp:  std::string cmd = "", tmp; bool done = false;
CommandLine.cpp:  std::cerr << "? ";
CommandLine.cpp:    for (size_t n = tmp.find(";"); ! done && n != std::string::npos; n = tmp.find(";"))
CommandLine.cpp:      if (cmd == "") cmd = prefix; else cmd = cmd + " " + prefix;
CommandLine.cpp:      cmd = "";
CommandLine.cpp:      if (cmd == "") cmd = tmp; else cmd = cmd + " " + tmp;
CommandLine.cpp:    std::cerr << "? ";
CommandLine.cpp:  if (cmd != "")
CommandLine.cpp:  if (filename == "-")
CommandLine.cpp:      std::cerr << "unable to open " << filename << "\n";
CommandLine.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
CommandLine.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
CommandLine.h:#include "SocketHandler.h"
DynamicLibraryManager.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
DynamicLibraryManager.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
DynamicLibraryManager.cpp:#include "Application.h"
DynamicLibraryManager.cpp:#include "MultiServer.h"
DynamicLibraryManager.cpp:#include "DynamicLibraryManager.h"
DynamicLibraryManager.cpp:  std::cerr << GetTheApplication()->GetRank() << ": closing " << name << "\n";
DynamicLibraryManager.cpp:    std::cerr << "Error opening SO " << name << ": " << dlerror() << "\n";
DynamicLibraryManager.cpp:  init = (void *(*)()) dlsym(handle, const_cast<char *>("init"));
DynamicLibraryManager.cpp:    std::cerr << "Error accessing init procedure in SO " << name << ": " << dlerror() << "\n";
DynamicLibraryManager.cpp:    std::cerr << "unable to load " << symbol << " from " << name << ": " << dlerror() << "\n";
DynamicLibraryManager.cpp:    std::cerr << (*i)->GetName() << " " << (*i).use_count() << "\n";
DynamicLibraryManager.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
DynamicLibraryManager.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
DynamicLibraryManager.h: * Galaxy's MultiServer supports multiple "applications" that conneact
DynamicLibraryManager.h:#include "KeyedObject.h"
IF.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
IF.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
IF.cpp:#include "IF.h"
IF.cpp:#include "rapidjson/document.h"
IF.cpp:#include "rapidjson/prettywriter.h"
IF.cpp:#include "rapidjson/stringbuffer.h"
IF.cpp:  if (v.HasMember("Datasets"))
IF.cpp:    Value& ds = v["Datasets"];
IF.cpp:      Add(ds[i]["name"].GetString(), ds[i]["type"].GetString(), ds[i]["filename"].GetString());
IF.cpp:  doc.Parse("{}");
IF.cpp:    d.AddMember("name", Value().SetString(it->name.c_str(), it->name.size()+1), doc.GetAllocator());
IF.cpp:    d.AddMember("type", Value().SetString(it->type.c_str(), it->type.size()+1), doc.GetAllocator());
IF.cpp:    d.AddMember("filename", Value().SetString(it->filename.c_str(), it->filename.size()+1), doc.GetAllocator());
IF.cpp:  doc.AddMember("Datasets", a, doc.GetAllocator());
IF.cpp:  strcpy(buf, "json ");
IF.cpp:    std::cerr << it->name << " " << it->type << " " << it->filename << "\n";
IF.cpp:  if (v.HasMember("Camera") || v.HasMember("Cameras"))
IF.cpp:    Value& c = v.HasMember("Camera") ? v["Camera"] : v["Cameras"];
IF.cpp:    eye[0] = c["viewpoint"][0].GetDouble();
IF.cpp:    eye[1] = c["viewpoint"][1].GetDouble();
IF.cpp:    eye[2] = c["viewpoint"][2].GetDouble();
IF.cpp:    if (c.HasMember("viewdirection"))
IF.cpp:      dir[0] = c["viewdirection"][0].GetDouble();
IF.cpp:      dir[1] = c["viewdirection"][1].GetDouble();
IF.cpp:      dir[2] = c["viewdirection"][2].GetDouble();
IF.cpp:    else if (c.HasMember("viewcenter"))
IF.cpp:      dir[0] = c["viewcenter"][0].GetDouble() - eye[0];
IF.cpp:      dir[1] = c["viewcenter"][1].GetDouble() - eye[1];
IF.cpp:      dir[2] = c["viewcenter"][2].GetDouble() - eye[2];
IF.cpp:        std::cerr << "need either viewdirection or viewcenter\n";
IF.cpp:    up[0] = c["viewup"][0].GetDouble();
IF.cpp:    up[1] = c["viewup"][1].GetDouble();
IF.cpp:    up[2] = c["viewup"][2].GetDouble();
IF.cpp:    aov = c["aov"].GetDouble();
IF.cpp:  doc.Parse("{}");
IF.cpp:  c.AddMember("viewpoint", e, doc.GetAllocator());
IF.cpp:  c.AddMember("viewdirection", d, doc.GetAllocator());
IF.cpp:  c.AddMember("viewup", u, doc.GetAllocator());
IF.cpp:  c.AddMember("aov", Value().SetDouble(aov), doc.GetAllocator());
IF.cpp:  doc.AddMember("Camera", c, doc.GetAllocator());
IF.cpp:  strcpy(buf, "json ");
IF.cpp:  std::cerr << "eye: " << eye[0] << " " << eye[1] << " " << eye[2] << "\n";
IF.cpp:  std::cerr << "dir: " << dir[0] << " " << dir[1] << " " << dir[2] << "\n";
IF.cpp:  std::cerr << "up: "  << up[0] << " " << up[1] << " " << up[2] << "\n";
IF.cpp:  std::cerr << "aov: " << aov << "\n";
IF.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
IF.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
IF.h:#include "SocketHandler.h"
IF.h:#include "dtypes.h"
IF.h:#include "rapidjson/document.h"
IF.h:#include "rapidjson/stringbuffer.h"
IF.h:      std::cerr << "IF sendrecv failed\n";
IF.h:    // std::cerr << "IF reply: " << s << "\n";
MultiServer.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServer.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServer.cpp:#include "MultiServer.h"
MultiServer.cpp:#include "MultiServerHandler.h"
MultiServer.cpp:    cerr << "RunServer failed\n";
MultiServer.cpp:   perror("ERROR opening socket");
MultiServer.cpp:    perror("ERROR on binding");
MultiServer.cpp:        cerr << "connection failed\n";
MultiServer.cpp:          perror("pthread_create");
MultiServer.cpp:  string s = "";
MultiServer.cpp:    s = s + i.first + ";";
MultiServer.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServer.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServer.h:#include "DynamicLibraryManager.h"
MultiServerHandler.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServerHandler.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServerHandler.cpp:#include "MultiServer.h"
MultiServerHandler.cpp:#include "MultiServerHandler.h"
MultiServerHandler.cpp:  std::string ok("ok");
MultiServerHandler.cpp:  server_func server = (server_func)dlp->GetSym("server");
MultiServerHandler.cpp:brk(){ std::cerr << "break\n"; }
MultiServerHandler.cpp:  if (cmd == "sbreak") { brk(); return true; }
MultiServerHandler.cpp:  else { std::cerr << "say what? " << cmd << " " << args << "\n"; return false; }
MultiServerHandler.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServerHandler.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServerHandler.h:#include "GalaxyObject.h"
MultiServerHandler.h:#include "KeyedObject.h"
MultiServerHandler.h:#include "SocketHandler.h"
MultiServerHandler.h:#include "MultiServer.h"
MultiServerHandler.h:#include "DynamicLibraryManager.h"
MultiServerObject.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServerObject.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServerObject.cpp:#include "Application.h"
MultiServerObject.cpp:#include "MultiServerHandler.h"
MultiServerObject.cpp:#include "MultiServerObject.h"
MultiServerObject.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
MultiServerObject.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
MultiServerObject.h:#include "MultiServerHandler.h"
ServerRendering.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
ServerRendering.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
ServerRendering.cpp:#include "ServerRendering.h"
ServerRendering.cpp:  // std::cerr << "n = " << n << " f = " << f << "\n";
ServerRendering.cpp:  // std::cerr << "  p[0]: " << p[0].x << " " << p[0].y << "\n";
ServerRendering.cpp:  // std::cerr << "  p[n-1]: " << p[n-1].x << " " << p[n-1].y << "\n";
ServerRendering.cpp:    // std::cerr << "after... n = " << n << " f = " << f << "\n";
ServerRendering.cpp:    // std::cerr << "skipped\n";
ServerRendering.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
ServerRendering.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
ServerRendering.h:#include "Application.h"
ServerRendering.h:#include "Rendering.h"
ServerRendering.h:#include "MultiServerHandler.h"
ServerRendering.h:#include "pthread.h"
SocketHandler.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
SocketHandler.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
SocketHandler.cpp:#include "SocketHandler.h"
SocketHandler.cpp:    std::cerr <<  "ERROR: no such host (" << host << ")\n";
SocketHandler.cpp:    perror("ERROR opening control socket");
SocketHandler.cpp:    perror("ERROR opening data sockets");
SocketHandler.cpp:    perror("setsockopt(SO_REUSEADDR) failed");
SocketHandler.cpp:    perror("ERROR connecting");
SocketHandler.cpp:    perror("select()");
SocketHandler.h:// Licensed under the Apache License, Version 2.0 (the "License");            //
SocketHandler.h:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
bparticles.state:    "Cameras": [
bparticles.state:            "annotation": "", 
bparticles.state:            "aov": 45, 
bparticles.state:            "viewcenter": [ 0, 0, 0 ], 
bparticles.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
bparticles.state:            "viewup": [ 0.0, 1.0, 0.0 ]
bparticles.state:    "Renderer": {
bparticles.state:    "Visualization": 
bparticles.state:            "annotation": "",
bparticles.state:            "Lighting": {
bparticles.state:                "Ka": 0.5, 
bparticles.state:                "Kd": 0.5, 
bparticles.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
bparticles.state:                "ao count": 0, 
bparticles.state:                "ao radius": 1.0, 
bparticles.state:                "shadows": false
bparticles.state:            "operators": [
bparticles.state:                    "colormap": [
bparticles.state:                    "dataset": "samples", 
bparticles.state:                    "type": "Particles"
bparticles.state:                    "colormap": [
bparticles.state:                    "dataset": "rsamples", 
bparticles.state:                    "type": "Particles"
data.in:  "Datasets":
data.in:      "name": "oneBall",
data.in:      "type": "Volume",
data.in:      "filename": "/Users/gda/galaxy/test/radial/data/radial-0-oneBall.vol"
datalib.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
datalib.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
datalib.cpp:#include "Datasets.h"
datalib.cpp:#include "MultiServer.h"
datalib.cpp:#include "MultiServerHandler.h"
datalib.cpp:#include "rapidjson/filereadstream.h"
datalib.cpp:extern "C" void
datalib.cpp:extern "C" bool
datalib.cpp:  DatasetsP theDatasets = Datasets::Cast(MultiServer::Get()->GetGlobal("global datasets"));
datalib.cpp:    MultiServer::Get()->SetGlobal("global datasets", theDatasets);
datalib.cpp:    cerr << "received " << line << "\n";
datalib.cpp:    std::string reply("ok");
datalib.cpp:    if (cmd == "import")
datalib.cpp:    else if (cmd == "list")
datalib.cpp:        reply = "unable to access datasets";
datalib.cpp:        reply = "datasets:\n";
datalib.cpp:          reply.append("\n");
datalib.cpp:    else if (cmd == "drop")
datalib.cpp:    else if (cmd == "delete")
datalib.cpp:        cerr << "couldn't find it in theDatasets\n";
datalib.cpp:    else if (cmd == "quit")
g.out:  (use "git push" to publish your local commits)
g.out:  (use "git reset HEAD <file>..." to unstage)
g.out:  (use "git add/rm <file>..." to update what will be committed)
g.out:  (use "git checkout -- <file>..." to discard changes in working directory)
g.out:  (use "git add <file>..." to include in what will be committed)
g.state:    "Cameras": [
g.state:            "annotation": "", 
g.state:            "aov": 45, 
g.state:            "viewcenter": [ 0, 0, 0 ], 
g.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
g.state:            "viewup": [ 0.0, 1.0, 0.0 ]
g.state:    "Renderer": {
g.state:    "Visualization": 
g.state:            "annotation": "",
g.state:            "Lighting": {
g.state:                "Ka": 0.5, 
g.state:                "Kd": 0.5, 
g.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
g.state:                "ao count": 0, 
g.state:                "ao radius": 1.0, 
g.state:                "shadows": false
g.state:            "operators": [
g.state:                    "dataset": "gsamples", 
g.state:                    "type": "Particles"
globalslib.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
globalslib.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
globalslib.cpp:#include "Application.h"
globalslib.cpp:#include "MultiServer.h"
globalslib.cpp:#include "MultiServerHandler.h"
globalslib.cpp:#include "MultiServerObject.h"
globalslib.cpp:    ~TestObject() { cerr << GetTheApplication()->GetRank() << ": TestObject dtor\n"; }
globalslib.cpp:      std::cerr << rank << ": " << to->get_string() << "\n";
globalslib.cpp:      std::cerr << "Rank " << rank << ":\n";
globalslib.cpp:    std::cerr << "Rank " << GetTheApplication()->GetRank() << ":\n";
globalslib.cpp:    std::cerr << "Rank " << GetTheApplication()->GetRank() << ": " << to->get_string() << "\n";
globalslib.cpp:extern "C" void
globalslib.cpp:  std::cerr << GetTheApplication()->GetRank() << ": libgxy_module_globals.so\n";
globalslib.cpp:extern "C" bool
globalslib.cpp:      cerr << "receive failed\n";
globalslib.cpp:    cerr << "received " << line << "\n";
globalslib.cpp:    if (cmd == "add")
globalslib.cpp:    else if (cmd == "show")
globalslib.cpp:        cerr << "no such object: " << name << "\n";
globalslib.cpp:    else if (cmd == "libs")
globalslib.cpp:    else if (cmd == "break")
globalslib.cpp:    else if (cmd == "drop")
globalslib.cpp:        cerr << "dropping " << name << "\n";
globalslib.cpp:        cerr << "no such object: " << name << "\n";
globalslib.cpp:    else if (cmd == "q" || cmd == "quit")
globalslib.cpp:    std::string ok("ok");
mhsamplelib.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
mhsamplelib.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
mhsamplelib.cpp:#include "Application.h"
mhsamplelib.cpp:#include "Datasets.h"
mhsamplelib.cpp:#include "Volume.h"
mhsamplelib.cpp:#include "Particles.h"
mhsamplelib.cpp:#include "MultiServer.h"
mhsamplelib.cpp:#include "MultiServerHandler.h"
mhsamplelib.cpp:  std::cerr << "created " << p->get_n_samples() << " samples\n";
mhsamplelib.cpp:extern "C" void
mhsamplelib.cpp:  std::cerr << GetTheApplication()->GetRank() << ": libgxy_module_mhsample.so\n";
mhsamplelib.cpp:extern "C" bool
mhsamplelib.cpp:  DatasetsP theDatasets = Datasets::Cast(MultiServer::Get()->GetGlobal("global datasets"));
mhsamplelib.cpp:    MultiServer::Get()->SetGlobal("global datasets", theDatasets);
mhsamplelib.cpp:      cerr << "receive failed\n";
mhsamplelib.cpp:    cerr << "received " << line << "\n";
mhsamplelib.cpp:    if (cmd == "sigma")       ss >> args.sigma;
mhsamplelib.cpp:    else if (cmd == "radius") ss >> args.radius;
mhsamplelib.cpp:    else if (cmd == "volume") 
mhsamplelib.cpp:    else if (cmd == "particles")
mhsamplelib.cpp:    else if (cmd == "iterations") ss >> args.n_iterations;
mhsamplelib.cpp:    else if (cmd == "startup") ss >> args.n_startup;
mhsamplelib.cpp:    else if (cmd == "skip") ss >> args.n_skip;
mhsamplelib.cpp:    else if (cmd == "miss") ss >> args.n_miss;
mhsamplelib.cpp:    else if (cmd == "color") ss >> args.r >> args.g >> args.b >> args.a;
mhsamplelib.cpp:    else if (cmd == "tf-linear") 
mhsamplelib.cpp:    else if (cmd == "tf-gaussian")
mhsamplelib.cpp:    else if (cmd == "tf-none")
mhsamplelib.cpp:    else if (cmd == "sample")
mhsamplelib.cpp:      if (!volume) std::cerr << "need a volume first\n";
mhsamplelib.cpp:      else if (!particles) std::cerr << "need someplace to put samples\n";
mhsamplelib.cpp:    std::string ok("ok");
msclient.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
msclient.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
msclient.cpp:#include "MultiServerHandler.h"
msclient.cpp:#include "CommandLine.h"
msclient.cpp:  cerr << "syntax: " << a << " [options]" << endl;
msclient.cpp:  cerr << "options:" << endl;
msclient.cpp:  cerr << "  -H host          host (localhost)" << endl;
msclient.cpp:  cerr << "  -P port          port (5001)" << endl;
msclient.cpp:  cerr << "  -so sofile       interface SO (libgxy_module_ping.so)\n";
msclient.cpp:  cerr << "  file ...         optional list of files of commands\n";
msclient.cpp:  string host = "localhost";
msclient.cpp:  string sofile = "libgxy_module_ping.so";
msclient.cpp:    if (!strcmp(argv[i], "-H")) host = argv[++i];
msclient.cpp:    else if (!strcmp(argv[i], "-P")) port = atoi(argv[++i]);
msclient.cpp:    else if (!strncmp(argv[i], "-D", 2)) { dbg = true, dbgarg = argv[i] + 2; break; }
msclient.cpp:    else if (!strcmp(argv[i], "-so")) { sofile = argv[++i]; }
msclient.cpp:    else if (!strcmp(argv[i], "-h")) syntax(argv[0]);
msclient.cpp:    cerr << "Sending sofile failed\n";
msserver.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
msserver.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
msserver.cpp:#include "Application.h"
msserver.cpp:#include "MultiServer.h"
msserver.cpp:#include "MultiServerHandler.h"
msserver.cpp:#include "CommandLine.h"
msserver.cpp:#include "Debug.h"
msserver.cpp:    cerr << "syntax: " << a << " [options]" << endl;
msserver.cpp:    cerr << "options:" << endl;
msserver.cpp:    cerr << "  -D         run debugger" << endl;
msserver.cpp:    cerr << "  -A         wait for attachment" << endl;
msserver.cpp:    cerr << "  -P port    port to use (5001)" << endl;
msserver.cpp:    if (!strcmp(argv[i], "-A")) dbg = true, atch = true;
msserver.cpp:    else if (!strncmp(argv[i], "-D", 2)) dbg = true, atch = false, dbgarg = argv[i] + 2;
msserver.cpp:    else if (!strcmp(argv[i], "-P")) port = atoi(argv[++i]);
msviewer.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
msviewer.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
msviewer.cpp:#include "dtypes.h"
msviewer.cpp:#include "Pixel.h"
msviewer.cpp:#include "ImageWriter.h"
msviewer.cpp:#include "ClientWindow.h"
msviewer.cpp:#include "IF.h"
msviewer.cpp:#include "CommandLine.h"
msviewer.cpp:#include "trackball.hpp"
msviewer.cpp:string statefile("");
msviewer.cpp:ImageWriter image_writer("async");
msviewer.cpp:#include "Debug.h"
msviewer.cpp:  cerr << "quit\n";
msviewer.cpp:    string s("render");
msviewer.cpp:      cerr << "render request send failed\n";
msviewer.cpp:    cerr << "state file " << sfile << "not found\n";
msviewer.cpp:  buffer << "json " << t.rdbuf();
msviewer.cpp:    cerr << "JSON send failed\n";
msviewer.cpp:      std::cerr << "PIXELS ERROR!\n";
msviewer.cpp:          string s("query datasets");
msviewer.cpp:            cerr << "sending query datasets failed\n";
msviewer.cpp:          cerr << "Datasets: " << s << "\n";
msviewer.cpp:                cerr << "P: " << p[0] << " " << p[1] << " " << p[2] << "\n";
msviewer.cpp:                cerr << "D: " << p[0] << " " << p[1] << " " << p[2] << "\n";
msviewer.cpp:                cerr << "U: " << p[0] << " " << p[1] << " " << p[2] << "\n";
msviewer.cpp:                cerr << "U: " << a << "\n";
msviewer.cpp:  cerr << "reshape: " << w << " " << h << "\n";
msviewer.cpp:  buffer << "window " << w << " " << h;
msviewer.cpp:    cerr << "sending reshape failed\n";
msviewer.cpp:  // cerr << "reshape reply: " << s << "\n";
msviewer.cpp:  glutCreateWindow("render");
msviewer.cpp:      // cerr << "reply to sending render request: " << s << "\n";
msviewer.cpp:  cerr << "syntax: " << a << " [options] statefile" << endl;
msviewer.cpp:  cerr << "options:" << endl;
msviewer.cpp:  cerr << "  -H host          host (localhost)" << endl;
msviewer.cpp:  cerr << "  -P port          port (5001)" << endl;
msviewer.cpp:  cerr << "  -D[which]        run debugger in selected processes.  If which is given, it is a number or a hyphenated range, defaults to all" << endl;
msviewer.cpp:  cerr << "  -so sofile       interface SO (libgxy_module_viewer.so)\n";
msviewer.cpp:  cerr << "  -A               wait for attachment" << endl;
msviewer.cpp:  cerr << "  -s w h           image size (512 x 512)" << endl;
msviewer.cpp:  cerr << "  -O               object-center model (default)" << endl;
msviewer.cpp:  cerr << "  -E               eye-center model" << endl;
msviewer.cpp:	cerr << "  -a age fadeout   sample age to begin fadeout (3.0), fadeout (1.0)" << endl;
msviewer.cpp:  cerr << "  -D               run debugger" << endl;
msviewer.cpp:void brk() { std::cerr << "break\n"; }
msviewer.cpp:  cmd = cmd.erase(0, cmd.find_first_not_of(" \t\n\r\f\v"));
msviewer.cpp:  else if (cmd == "quit") return true;
msviewer.cpp:  else if (cmd == "break") brk();
msviewer.cpp:  else if (cmd == "file")
msviewer.cpp:      std::cerr << "unable to open " << filename << "\n";
msviewer.cpp:      cerr << "send/receive failed\n";
msviewer.cpp:    if (cmd != "ok")
msviewer.cpp:      cout << "reply: " << line << "\n";
msviewer.cpp:  string cmd = "", tmp; bool done = false;
msviewer.cpp:  cerr << "? ";
msviewer.cpp:    for (size_t n = tmp.find(";"); ! done && n != string::npos; n = tmp.find(";"))
msviewer.cpp:      if (cmd == "") cmd = prefix; else cmd = cmd + " " + prefix;
msviewer.cpp:      cmd = "";
msviewer.cpp:      if (cmd == "") cmd = tmp; else cmd = cmd + " " + tmp;
msviewer.cpp:    cerr << "? ";
msviewer.cpp:  if (cmd != "")
msviewer.cpp:  string host = "localhost";
msviewer.cpp:  string statefile = "";
msviewer.cpp:  string sofile = "libgxy_module_viewer.so";
msviewer.cpp:    if (!strcmp(argv[i], "-a")) { age = atof(argv[++i]), fadeout = atof(argv[++i]); }
msviewer.cpp:    else if (!strcmp(argv[i], "-H")) host = argv[++i];
msviewer.cpp:    else if (!strncmp(argv[i],"-D", 2)) dbg = true, atch = false, dbgarg = argv[i] + 2;
msviewer.cpp:    else if (!strcmp(argv[i], "-P")) port = atoi(argv[++i]);
msviewer.cpp:		else if (!strncmp(argv[i], "-D", 2)) { dbg = true, dbgarg = argv[i] + 2; break; }
msviewer.cpp:    else if (!strcmp(argv[i], "-O")) { mode = OBJECT_CENTER; }
msviewer.cpp:    else if (!strcmp(argv[i], "-E")) { mode = EYE_CENTER; }
msviewer.cpp:    else if (!strcmp(argv[i], "-so")) { sofile = argv[++i]; }
msviewer.cpp:    else if (!strcmp(argv[i], "-s"))
msviewer.cpp:    else if (statefile == "")
msviewer.cpp:  if (statefile == "")
particles.state:    "Cameras": [
particles.state:            "annotation": "", 
particles.state:            "aov": 45, 
particles.state:            "viewcenter": [ 0, 0, 0 ], 
particles.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
particles.state:            "viewup": [ 0.0, 1.0, 0.0 ]
particles.state:    "Renderer": {
particles.state:    "Visualization": 
particles.state:            "annotation": "",
particles.state:            "Lighting": {
particles.state:                "Ka": 0.5, 
particles.state:                "Kd": 0.5, 
particles.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
particles.state:                "ao count": 0, 
particles.state:                "ao radius": 1.0, 
particles.state:                "shadows": false
particles.state:            "operators": [
particles.state:                    "color": [ 1.0, 0.0, 0.0, 1.0 ],
particles.state:                    "dataset": "samples", 
particles.state:                    "type": "Particles"
pinglib.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
pinglib.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
pinglib.cpp:#include "Application.h"
pinglib.cpp:#include "MultiServer.h"
pinglib.cpp:#include "MultiServerHandler.h"
pinglib.cpp:      std::cerr << ((char *)get()) << ": " << rank << "\n";
pinglib.cpp:      std::cerr << "ping signalling\n";
pinglib.cpp:extern "C" void
pinglib.cpp:  PingMsg p("ping");
pinglib.cpp:  cerr << "ping done\n";
pinglib.cpp:extern "C" bool
pinglib.cpp:      cerr << "receive failed\n";
pinglib.cpp:    cerr << "received " << line << "\n";
pinglib.cpp:    if (line == "ping")
pinglib.cpp:    else if (line == "quit")
pinglib.cpp:    std::string ok("ok");
r.state:    "Cameras": [
r.state:            "annotation": "", 
r.state:            "aov": 45, 
r.state:            "viewcenter": [ 0, 0, 0 ], 
r.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
r.state:            "viewup": [ 0.0, 1.0, 0.0 ]
r.state:    "Renderer": {
r.state:    "Visualization": 
r.state:            "annotation": "",
r.state:            "Lighting": {
r.state:                "Ka": 0.5, 
r.state:                "Kd": 0.5, 
r.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
r.state:                "ao count": 0, 
r.state:                "ao radius": 1.0, 
r.state:                "shadows": false
r.state:            "operators": [
r.state:                    "dataset": "rsamples", 
r.state:                    "type": "Particles"
rg.state:    "Cameras": [
rg.state:            "annotation": "", 
rg.state:            "aov": 45, 
rg.state:            "viewcenter": [ 0, 0, 0 ], 
rg.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
rg.state:            "viewup": [ 0.0, 1.0, 0.0 ]
rg.state:    "Renderer": {
rg.state:    "Visualization": 
rg.state:            "annotation": "",
rg.state:            "Lighting": {
rg.state:                "Ka": 0.5, 
rg.state:                "Kd": 0.5, 
rg.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
rg.state:                "ao count": 0, 
rg.state:                "ao radius": 1.0, 
rg.state:                "shadows": false
rg.state:            "operators": [
rg.state:                    "dataset": "gsamples", 
rg.state:                    "type": "Particles"
rg.state:                    "dataset": "rsamples", 
rg.state:                    "type": "Particles"
rparticles.state:    "Cameras": [
rparticles.state:            "annotation": "", 
rparticles.state:            "aov": 45, 
rparticles.state:            "viewcenter": [ 0, 0, 0 ], 
rparticles.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
rparticles.state:            "viewup": [ 0.0, 1.0, 0.0 ]
rparticles.state:    "Renderer": {
rparticles.state:    "Visualization": 
rparticles.state:            "annotation": "",
rparticles.state:            "Lighting": {
rparticles.state:                "Ka": 0.5, 
rparticles.state:                "Kd": 0.5, 
rparticles.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
rparticles.state:                "ao count": 0, 
rparticles.state:                "ao radius": 1.0, 
rparticles.state:                "shadows": false
rparticles.state:            "operators": [
rparticles.state:                    "colormap": [
rparticles.state:                    "dataset": "rsamples", 
rparticles.state:                    "type": "Particles"
s.state:    "Cameras": [
s.state:            "annotation": "", 
s.state:            "aov": 45, 
s.state:            "viewcenter": [ 0, 0, 0 ], 
s.state:            "viewpoint": [ 0.0, 0.0, 4.0], 
s.state:            "viewup": [ 0.0, 1.0, 0.0 ]
s.state:    "Renderer": {
s.state:    "Visualization": 
s.state:            "annotation": "",
s.state:            "Lighting": {
s.state:                "Ka": 0.5, 
s.state:                "Kd": 0.5, 
s.state:                "Sources": [ [ 1, 2, 0, 1 ] ], 
s.state:                "ao count": 0, 
s.state:                "ao radius": 1.0, 
s.state:                "shadows": false
s.state:            "operators": [
s.state:                    "dataset": "samples", 
s.state:                    "type": "Particles"
single.state:    "Cameras": [
single.state:            "annotation": "", 
single.state:            "aov": 45, 
single.state:            "viewcenter": [ 0, 0, 0 ], 
single.state:            "viewpoint": [ 0.0, 0.0, 3 ], 
single.state:            "viewup": [ 0.0, 1.0, 0.0 ]
single.state:    "Renderer": {
single.state:    "Visualization": 
single.state:            "annotation": "",
single.state:            "Lighting": {
single.state:                "Ka": 0.5, 
single.state:                "Kd": 0.5, 
single.state:                "Sources": [ [ 1, 2, 4 ] ], 
single.state:                "ao count": 0, 
single.state:                "ao radius": 1.0, 
single.state:                "shadows": false
single.state:            "operators": [
single.state:                    "colormap": [
single.state:                    "dataset": "oneBall", 
single.state:                    "isovalues": [
single.state:                    "opacitymap": [
single.state:                    "type": "Volume"
single.state:                    "colormap": [
single.state:                    "dataset": "oneBall", 
single.state:                    "opacitymap": [
single.state:                    "plane": [ 0.0, 0.0, 1.0, 0.0 ], 
single.state:                    "type": "Volume"
single.state:                    "colormap": [
single.state:                    "dataset": "oneBall", 
single.state:                    "opacitymap": [
single.state:                    "plane": [ 1.0, 0.0, 0.0, 0.0 ], 
single.state:                    "type": "Volume"
test.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
test.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
test.cpp:#include "MultiServerSocket.h"
test.cpp:  cerr << "syntax: " << a << " [options] statefile" << endl;
test.cpp:  cerr << "options:" << endl;
test.cpp:  cerr << "  -H host    host (localhost)" << endl;
test.cpp:  cerr << "  -P port    port (5001)" << endl;
test.cpp:  cerr << "  -so sofile       interface SO (libtestlib.so)\n";
test.cpp:  string host = "localhost";
test.cpp:  string sofile = "libtestlib.so";
test.cpp:    if (!strcmp(argv[i], "-H")) host = argv[++i];
test.cpp:    else if (!strcmp(argv[i], "-P")) port = atoi(argv[++i]);
test.cpp:		else if (!strncmp(argv[i], "-D", 2)) { dbg = true, dbgarg = argv[i] + 2; break; }
test.cpp:    else if (!strcmp(argv[i], "-so")) { sofile = argv[++i]; }
test.cpp:    cerr << "Sending sofile failed\n";
test.cpp:    cerr << "? ";
test.cpp:    if (cmd == "q")
test.cpp:        cerr << "send/receive failed\n";
test.cpp:      cout << "reply: " << cmd << "\n";
trackball.hpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
trackball.hpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
trackball.hpp:#include "dtypes.h" 
viewerlib.cpp:// Licensed under the Apache License, Version 2.0 (the "License");            //
viewerlib.cpp:// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  //
viewerlib.cpp:#include "rapidjson/document.h"
viewerlib.cpp:#include "Renderer.h"
viewerlib.cpp:#include "MultiServer.h"
viewerlib.cpp:#include "MultiServerHandler.h"
viewerlib.cpp:#include "ServerRendering.h"
viewerlib.cpp:#include "trackball.hpp"
viewerlib.cpp:    datasets = Datasets::Cast(MultiServer::Get()->GetGlobal("global datasets"));
viewerlib.cpp:      MultiServer::Get()->SetGlobal("global datasets", datasets);
viewerlib.cpp:    std::string ok("render ok");
viewerlib.cpp:void brk() { std::cerr << "server break\n"; }
viewerlib.cpp:extern "C" bool
viewerlib.cpp:  DatasetsP theDatasets = Datasets::Cast(MultiServer::Get()->GetGlobal("global datasets"));
viewerlib.cpp:    MultiServer::Get()->SetGlobal("global datasets", theDatasets);
viewerlib.cpp:		std::cerr << "> " << line << "\n";
viewerlib.cpp:    if (cmd == "sbreak")
viewerlib.cpp:		else if (cmd == "permute_pixels")
viewerlib.cpp:			if (onoff == "on")
viewerlib.cpp:			else if (onoff == "off")
viewerlib.cpp:				std::cerr << "invalid permute_pixels: arg must be on or off\n";
viewerlib.cpp:		else if (cmd == "max_rays_per_packet")
viewerlib.cpp:    else if (cmd == "commit")
viewerlib.cpp:    else if (cmd == "json")
viewerlib.cpp:      if (doc.HasMember("Datasets"))
viewerlib.cpp:      if (doc.HasMember("Visualization"))
viewerlib.cpp:        renderingState.GetTheVisualization()->LoadFromJSON(doc["Visualization"]);
viewerlib.cpp:      if (doc.HasMember("Camera"))
viewerlib.cpp:        renderingState.GetTheCamera()->LoadFromJSON(doc["Camera"]);
viewerlib.cpp:      if (doc.HasMember("Renderer"))
viewerlib.cpp:    else if (cmd == "window")
viewerlib.cpp:    else if (cmd == "render")
viewerlib.cpp:    std::string ok("ok");
viewerlib.cpp:extern "C" void
x:  cmd = cmd.erase(0, cmd.find_first_not_of(" \t\n\r\f\v"));
x:  else if (cmd == "quit") return true;
x:  else if (cmd == "break") brk();
x:  else if (cmd == "file")
x:      std::cerr << "unable to open " << filename << "\n";
x:      cerr << "send/receive failed\n";
x:    if (cmd != "ok")
x:      cout << "reply: " << line << "\n";
x:  string cmd = "", tmp; bool done = false;
x:  cerr << "? ";
x:    for (size_t n = tmp.find(";"); ! done && n != string::npos; n = tmp.find(";"))
x:      if (cmd == "") cmd = prefix; else cmd = cmd + " " + prefix;
x:      cmd = "";
x:      if (cmd == "") cmd = tmp; else cmd = cmd + " " + tmp;
x:    cerr << "? ";
x:  if (cmd != "")
